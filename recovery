#!/bin/sh
#
# Copyright (C) 2016 Dream Property GmbH
#

BASE_URI=http://dreamboxupdate.com/download/recovery/dm7080/release
FILENAME=dreambox-image-dm7080.tar.xz
MMC_DEVICE=/dev/mmcblk0
ROOT_PARTITION=/dev/mmcblk0p1
ROOT_MOUNTPOINT=/mnt
ROOT_NAME=dreambox-rootfs
DATA_PARTITION=/dev/mmcblk0p2
DATA_MOUNTPOINT=/data
DATA_NAME=dreambox-data
RECOVERY_CACHE=${DATA_MOUNTPOINT}/.recovery
FILESYSTEM=ext4

MOUNTPOINTS=
WORKSPACE=

set -e

exec 3>/dev/null
exec 4>&2
exec 5>&1

is_blockdev()
{
	[ -b "${1}" ]
}

is_chardev()
{
	[ -c "${1}" ]
}

is_directory()
{
	[ -d "${1}" ]
}

is_file()
{
	[ -f "${1}" ]
}

is_readable()
{
	[ -r "${1}" ]
}

is_readable_file()
{
	is_file "${1}" && is_readable "${1}"
}

is_writable()
{
	[ -w "${1}" ]
}

is_writable_blockdev()
{
	is_blockdev "${1}" && is_writable "${1}"
}

is_writable_chardev()
{
	is_chardev "${1}" && is_writable "${1}"
}

is_empty()
{
	[ -z "${1}" ]
}

is_initrd()
{
	is_file "/etc/initrd-release"
}

is_nfsroot()
{
	is_readable_file /proc/cmdline && grep -q -w root=/dev/nfs /proc/cmdline
}

is_mountpoint()
{
	is_directory "${1}" && mountpoint -q `realpath "${1}"`
}

is_mounted()
{
	if is_blockdev "${1}"; then
		is_mountpoint "${2}" && [ `mountpoint -x "${1}"` = `mountpoint -d "${2}"` ]
	else
		is_mountpoint "${2}" && grep -q "^${1}\s${2}\s" /proc/mounts
	fi
}

cleanup()
{
	IFS=:
	for dir in ${MOUNTPOINTS}; do
		unmount "${dir}"
	done
	unset IFS

	is_empty "${WORKSPACE}" || rm -rf "${WORKSPACE}"
}

abort()
{
	echo "Fatal: $@"
	exit 1
}

warn()
{
	echo "Warning: $@" >&5
}

info()
{
	echo "[*] $@" >&5
}

create_directory()
{
	if ! is_directory "${1}"; then
		info "Creating directory '${1}'"
		mkdir -p "${1}" >&3 2>&4
	fi
}

create_filesystem()
{
	info "Creating ${FILESYSTEM} filesystem '${1}' on ${2}"
	xtrap mkfs.${FILESYSTEM} -F -L "${1}" "${2}"
}

blkdev_has_filesystem()
{
	is_blockdev "${1}" && (
		if hash blkid 2>/dev/null; then
			blkid -o export "${1}" | grep -q "^TYPE=${FILESYSTEM}$"
		else
			local dir=`mktemp -d -p ${WORKSPACE}` || abort 'Failed to create temporary mount point'
			grep -q "^${1}\s[^\s]\+\s${FILESYSTEM}\s" /proc/mounts || (mount -t ${FILESYSTEM} -o ro "${1}" "${dir}" 2>/dev/null && umount "${dir}")
		fi
	)
}

create_nand_filesystem()
{
	info "Creating ${FILESYSTEM} filesystem on ${1}"
	xtrap mkfs.${FILESYSTEM} "${1}"
}

erase()
{
	info "Erasing flash memory on ${1}"
	xtrap flash_erase "${1}" 0 0
}

format_ubi_device()
{
	info "Formatting ${1} for UBI"
	xtrap ubiformat -y "${1}"
}

attach_ubi_device()
{
	info "Attaching ${1} to UBI"
	xtrap ubiattach -d "${UBI_ID}" -p "${1}"
}

remove_ubi_volume()
{
	info "Removing volume ${UBI_VOL_ID} from ${UBI_DEVICE}"
	xtrap ubirmvol "${UBI_DEVICE}" -n "${UBI_VOL_ID}"
}

create_ubi_volume()
{
	info "Creating volume ${UBI_VOL_ID} on ${UBI_DEVICE} (${ROOT_NAME})"
	xtrap ubimkvol "${UBI_DEVICE}" -n "${UBI_VOL_ID}" -N "${ROOT_NAME}" -m
}

create_partition_table()
{
	info "Creating partition table"
	if hash sgdisk 2>/dev/null; then
		xtrap sgdisk -z \
			-n 1:147456:2097151 -c 1:rootfs -t 1:8307 \
			-n 2:2097152: -c 2:data -t 2:8300 "${1}"
	else
		xtrap parted --script --align=optimal "${1}" -- \
			mklabel gpt \
			mkpart primary ext2 72MiB 1GiB \
			mkpart primary ext2 1GiB 100% >&3 2>&4
	fi
}

create_workspace()
{
	umask 077

	WORKSPACE=`mktemp -d` || abort 'Failed to create working directory'
	trap cleanup EXIT INT
	cd "${WORKSPACE}" || abort 'Failed to change working directory'
}

extract_tarball()
{
	info "Extracting '${1}' to '${2}'"
	xtar -xf "${1}" -C "${2}"
}

fetch()
{
	info "Downloading '${1}/${2}'"
	wget -q "${1}/${2}" -O "${2}" >&3 2>&4
}

verify()
{
	info "Verifying signature of '${1}'"
	gpgv -q --ignore-time-conflict "${1}.sig" "${1}" >&3 2>&4
}

files_equal()
{
	cmp -s "${1}" "${2}"
}

fetch_signed()
{
	fetch "${1}" "${2}.sig" || true

	if is_file "${RECOVERY_CACHE}/${2}" && is_file "${RECOVERY_CACHE}/${2}.sig"; then
		if ! is_file "${2}.sig" || files_equal "${2}.sig" "${RECOVERY_CACHE}/${2}.sig"; then
			info "Copying '${2}' from local storage"
			xcp "${RECOVERY_CACHE}/${2}.sig" "${2}.sig"
			xcp "${RECOVERY_CACHE}/${2}" "${2}"
		fi
	fi

	is_file "${2}.sig" || abort "Failed to obtain signature '${2}.sig'"
	is_file "${2}" && verify "${2}" || {
		fetch "${1}" "${2}" || abort "Failed to download '${2}'"
		verify "${2}" || abort 'Failed to verify signature'
	}
}

safe_mount()
{
	local device="${1}"
	local dir="${2}"
	shift 2

	if is_mounted "${device}" "${dir}"; then
		info "Remounting '${device}' to '${dir}'"
		mount -o remount $@ "${device}" "${dir}"
	else
		create_directory "${dir}"
		info "Mounting '${device}' to '${dir}'"
		mount $@ "${device}" "${dir}" && MOUNTPOINTS="${dir}:${MOUNTPOINTS}"
	fi
}

unmount()
{
	if is_mountpoint "${1}"; then
		info "Unmounting '${1}'"
		umount "${1}" || mount -o remount,ro "${1}"
	fi
}

mount_cache()
{
	if is_blockdev "${DATA_PARTITION}"; then
		safe_mount "${DATA_PARTITION}" "${DATA_MOUNTPOINT}" -o ro || warn "Failed to mount data filesystem"
	fi
}

cache_changed()
{
	is_mountpoint "${DATA_MOUNTPOINT}" && ! cmp -s "${RECOVERY_CACHE}/${1}.sig" "${1}.sig"
}

remount_cache_rw()
{
	is_mountpoint "${DATA_MOUNTPOINT}" && info "Remounting '${DATA_MOUNTPOINT}' (rw)" && \
		mount -o remount,rw "${DATA_MOUNTPOINT}" && is_writable "${DATA_MOUNTPOINT}"
}

update_cache()
{
	if [ -f "${1}" ] && remount_cache_rw; then
		create_directory "${RECOVERY_CACHE}"
		if is_directory "${RECOVERY_CACHE}"; then
			info "Updating recovery cache (${1})"
			xcp "${1}" "${RECOVERY_CACHE}/${1}" || true
		fi
	fi
}

update_cache_signed()
{
	if cache_changed "${1}" && remount_cache_rw; then
		create_directory "${RECOVERY_CACHE}"
		if is_directory "${RECOVERY_CACHE}"; then
			info "Updating recovery cache (${1})"
			xcp "${1}" "${RECOVERY_CACHE}/${1}" || true
			xcp "${1}.sig" "${RECOVERY_CACHE}/${1}.sig" || true
		fi
	fi
}

unmount_cache()
{
	unmount "${DATA_MOUNTPOINT}"
}

run_postinsts()
{
	local virtfs="dev proc run sys tmp"
	local mountpoint=$1
	shift

	if [ -d "${mountpoint}/var/lib/dpkg/info" ]; then
		pkgtype="dpkg"
	elif [ -d "${mountpoint}/var/lib/opkg/info" ]; then
		pkgtype="opkg"
	else
		warn "Unknown package manager, can't run postinst scripts"
		return
	fi

	for fs in ${virtfs}; do
		safe_mount /${fs} ${mountpoint}/${fs} -o bind || abort "Failed to mount ${mountpoint}/${fs}"
	done
	for package in $@; do
		if [ -x "${mountpoint}/var/lib/${pkgtype}/info/${package}.postinst" ]; then
			xchroot ${mountpoint} /var/lib/${pkgtype}/info/${package}.postinst || abort "Failed to run ${package}.postinst"
		fi
	done
	for fs in ${virtfs}; do
		unmount ${mountpoint}/${fs} || warn "Failed to unmount ${mountpoint}/${fs}"
	done
}

assert_rescue_mode()
{
	is_initrd || is_nfsroot || abort "This script may only run in rescue mode!"
}

usage()
{
	echo "Usage: ${0} [-bhqrtv]"
	exit ${1}
}

std_opt()
{
	case "${1}" in
		q)
			exec 3>/dev/null
			exec 4>/dev/null
			exec 5>/dev/null
			;;
		t)
			set -x
			;;
		v)
			exec 3>&1
			exec 4>&2
			exec 5>&1
			;;
		h|'?')
			if [ "${1}" = "h" ]; then
				usage 0
			else
				usage 1
			fi
			;;
	esac
}

xcp()
{
	xtrap cp -a $@
}

xchroot()
{
	xtrap chroot $@
}

xdd()
{
	xtrap dd conv=fsync $@
}

xrealpath()
{
	local opt

	if realpath -v >/dev/null 2>&1; then
		opt="-s"
	else
		opt="-m"
	fi

	realpath ${opt} "${1}"
}

xtar()
{
	local opt

	if tar --usage >/dev/null 2>&1; then
		opt="--warning=no-timestamp"
	else
		opt=""
	fi

	xtrap tar --numeric-owner ${opt} $@
}

xtrap()
{
	(trap '' HUP INT TERM; exec $@) >&3 2>&4
}

BACKUP_SETTINGS=":"
RESTORE_SETTINGS=":"
SETTINGS="settings.tar.gz"

while getopts bhqrtv opt; do
	case "${opt}" in
		b)
			BACKUP_SETTINGS="backup-settings ${SETTINGS}"
			;;
		r)
			RESTORE_SETTINGS="restore-settings ${SETTINGS}"
			;;
	esac
	std_opt "${opt}"
done

assert_rescue_mode

is_writable_blockdev "${MMC_DEVICE}" || abort "Target block device '${MMC_DEVICE}' is not a writable block device"

create_workspace
export GNUPGHOME="${WORKSPACE}"

(base64 -d > trustedkeys.gpg || abort 'Failed to write public key') << EOF
mQENBFPo2oUBCAC6dzqe5azBCkxzj99xNfzwB4L6tHzz83zqD2KUQuuJMhO7Q2g9AHnSNQ0z1+Bz
oX2gGX90FusBSLiCuZmNdnxlcl7KVfBe37EpYtQNGCZKlWeruCAUdJGKIyPJXDvkXCy3dj6z1ho8
p1r3uazEbUbJyLvwjzcg0Ua1qxFjLoq/h15yDgd0NCkMStL6gwKdmReLRfE/tn0K53CVQzIeEFyn
EW3N0tu2deiYkanHy/MM9IOIv3oQmoEWNaVsDf+gG7nUPj0QE66GOYlBugR5vNi3BorOctarQp/8
Dh56muiqomwwewJubzsvjUjpiYXdO/3RN2gOej2+5hUCiYmvOahfABEBAAG0LkRyZWFtYm94IERN
NzA4MCBSZWNvdmVyeSA8cmVjb3ZlcnlAZG03MDgwLmNvbT6JATgEEwECACIFAlPo2oUCGwMGCwkI
BwMCBhUIAgkKCwQWAgMBAh4BAheAAAoJEBWob67Wz1bnUGYH/0zmTS7Gtvv97oHHnz3JSkLybDRj
Jx/wH+vpzyCRl8rC7TlHs5GBfjoJ1Hjo4DsZqElTb8g+kg5WGzMBUUuwabRhZuf2CL7/IPKP+LWH
t2ByZX3OgS1Q+HDLob5wlKllD9y/wwekuwS/8cgdnDH9URHCBqIt5gWQzLU1pvmQrKPXM1aMsLQj
16vbktXNkREF/cNhWfQFQs2dOwmzNEDeuE32I6h7PYl1bFP0hCOmbkcTuibnC+tsWOJMKF1iZ8bq
xDND9BYTwGtD2SVrddu3i4kBz6hka01ZnfSUZewpu+TrCgaD6oENfarPiC9VYfKEFi10RIPIxwRX
s1tBOOQNKpywAgAD
EOF

mount_cache
fetch_signed "${BASE_URI}" "${FILENAME}"

[ ! -f "${RECOVERY_CACHE}/settings.tar.gz" ] || cp ${RECOVERY_CACHE}/settings.tar.gz ${SETTINGS}
if blkdev_has_filesystem "${ROOT_PARTITION}"; then
	${BACKUP_SETTINGS}
fi
[ "${RESTORE_SETTINGS}" = ":" -o -f "${SETTINGS}" ] || abort "Can't restore settings without prior backup!"

if ! is_blockdev "${ROOT_PARTITION}" || ! blkdev_has_filesystem "${DATA_PARTITION}"; then
	unmount "${ROOT_MOUNTPOINT}" || abort "Failed to unmount root filesystem"
	unmount "${DATA_MOUNTPOINT}" || abort "Failed to unmount data filesystem"
	if ! is_blockdev "${ROOT_PARTITION}" || ! is_blockdev "${DATA_PARTITION}"; then
		create_partition_table "${MMC_DEVICE}" || abort "Failed to partition disk"
	fi
	if ! blkdev_has_filesystem "${DATA_PARTITION}"; then
		create_filesystem "${DATA_NAME}" "${DATA_PARTITION}" || warn "Failed to create ${FILESYSTEM} filesystem '${DATA_NAME}' on '${DATA_PARTITION}'"
	fi
	mount_cache
fi

unmount "${ROOT_MOUNTPOINT}" || abort "Failed to unmount root filesystem"
create_filesystem "${ROOT_NAME}" "${ROOT_PARTITION}" || abort "Failed to create ${FILESYSTEM} filesystem '${ROOT_NAME}' on '${ROOT_PARTITION}'"
safe_mount "${ROOT_PARTITION}" "${ROOT_MOUNTPOINT}" || abort "Failed to mount root filesystem"
extract_tarball "${FILENAME}" "${ROOT_MOUNTPOINT}" || abort "Failed to extract root filesystem"
run_postinsts "${ROOT_MOUNTPOINT}" dreambox-secondstage kernel-image || abort "Failed to run postinst scripts"
${RESTORE_SETTINGS}
unmount "${ROOT_MOUNTPOINT}" || warn "Failed to unmount root filesystem"

[ "${BACKUP_SETTINGS}" = ":" ] || update_cache "${SETTINGS}"
update_cache_signed "${FILENAME}"
unmount_cache

info "Initiating reboot"
sync && reboot || warn 'Failed to initiate reboot'
